1. How Session Keys are Exchanged and How SMB Signing Works
    Session Keys are never exchanged between the client and the server.
    Server gets the Session key from Kerberos / NTLM, based on which is used for authentication.

    Let us take Kerberos as the authentication mechanism.
    When the client joins to the domain where the server resides, Kerberos will create an entry for the client.

    Later when the client tries to map a share on the server, server will check if this client is authenticated by asking Kerberos.
    If the client is authenticated then Kerberos would send the server the Session key for that client.

    From now on server will start using the Session key.

    This is a brief of how it works. Kerberos takes care of generating the Session key based on the Client's auth information.
    this key is later passed to the server.

    Note on how signing/encryption keys are generated for session setup and session bind request.
    1. On successful session setup we create a new channel and derive all the keys: signing,
       encryption and decryption key from the session key that is coming from the security context
       (returned by secd). For Smb3.1, preAuthIntegretyHash value from the connection is used for
       generating the above keys. All the keys from the primary channel are copied on to the session
       object as well.
    2. According to the spec negotiate and session setup request can never be signed or encrypted,
       however session bind request can be signed but not encrypted. Thus for all the requests
       (except Negotiate/SessionSetup/SessionBind) signing validation can happen at the
       Smb2CompoundProcessor level as we will be getting keys from the channel object, however for
       session bind request, it will happen at the command level.
    3. Session bind request is different because it will be signed using the signing key of
       the primary channel whereas all other request are signed using its own channel's signing key.
       Since the primary channel can go away, we keep a copy in the session object. At the command
       level after we figure out it is a session bind, we will look
       up the session object for the signing key and do signature validation. This is true for all the
       intermediate/final session bind request and intermediate session bind responses. The final
       session bind response will be signed using the signing key for the new channel just like
       it happens for any other request. Thus during session bind, we will create a channel and copy
       all the keys from the session onto this new channel. This helps us in following way:
       3.1 Now session's signing key is available in channel object itself. Thus code used for
           signing the intermediate session bind responses can use the signing key
           available in the channel. Once the the channel is validated by secd, we can derive
           the new signing key for this channel and overwrite the old one.
       3.2 Encrption and Decryption key of the session is now available in channel. Thus now
           encryption/decryption code can access these keys without taking session lock.
    
    SMB 3.1
    //==============================================================================
    // ComputePreAuthIntegrityHash()
    //
    //   This function  generates Pre-Auth intergrity hash which is used by SMB3.1
    //   negotiate and Session Setup request processing.
    //
    //   Hash is computed as..
    //      Hash = SHA512(CurrentHash + Message)
    //
    //   Where
    //          CurrentHash: This is the hash computed for the previous message, which
    //                       could be the response for previous message or the current
    //                       request. For Negotiate request which is the first request
    //                       on the connection, CurrentHash is 64 bytes of zeros.
    //
    //          Message: Current message which could be incoming request or the
    //                   response generated by server.
    //
    // pFirstBuffer
    //   This is the First GBuf in the chain which contains the data for which the
    //   hash has to be computed.
    //
    // startOffset
    //   This is the starting offset byte of the message data in the first buffer.
    //
    // messageLength
    //   Length of the messag in buffer chain.
    //
    // pCurrentHash
    //   Pointer to 64 byte current hash
    //
    // pMac
    //   Generated hash


2. How NTLM Authentication Works
https://blogs.msdn.microsoft.com/chiranth/2013/09/20/ntlm-want-to-know-how-it-works/
    - It uses a CHALLENGE based system
    - NTLM when IP address is used
    - NTLM if Ports are blocked by firewall
    - NTLM if either of the parites is not in a domain

    1. User uses a USername and Password to login to Client Machine
        - Client computes a HASH of the password 
        - Client discards the actual password
    2. Clients sends Username to Server
    3. Server computes a Random 16-byte Nounce (CHALLENGE) and sends it to client
    4. Client uses the HASH got in Step 1 to ENCRYPT the Challenge
        - Client returns the Encrypted Nounce to the Server
    5. Server sends the following to DC
        - User name
        - Encrypted Nounce
        - Challenge sent to client
    6. DC uses
        - USername to get the HASH of the Actual Password
        - Uses the Above Hash to Encrypt the Challenge
        - Compares Encrypted Nounce with the one Computed
    7. If match success else failure

3. How Kerberos Works
https://www.youtube.com/watch?v=kp5d8Yv3-0c
    - Can be used only when DOMAIN is used
    - If we directly use the IP address then the CLIENT does not go to the DC to resolve
      the Domain's IP address. Instead it goes directly to the Server and KDC does not
      come in the picture

    - Three Parties are involved
        1. Client (Has Client KEY)
        2. Server (Has Server KEY)
        3. Key Distribution Center KDC (Has Client Key, Server KEy and KDC Key)
           - In a AD network it is the AD DC
           - Brings everybody together
    - In Kerberos no communication between KDC and Server
    - Client takes the majority of processing burder in Kerberos

    1. Client constructs and Authenticator which contain basic info about the client.
        - This authenticator is GOOD only for a short time
        - A portion of the authenticator is UNENCRYPTED (USer name etc).
            - This will help KDC/DC in finding who the guy is
        - A portion is ENCRYPTED using USER'S PASSWORD
            - USer's password is used as ENCRYPTION KEY
            - So password need not be SENT over the network

    2. KDC receives the Authenticator from the Client.
        - KDC knows the Client's Password
        - KDC will use that password to try to decrypt the Authenticator
        - If FAILURE then incorrect password and reject it
        - If SUCCESS then the client is legitimate

        - Once Success THE AUTHENTICATOR is no longer needed.
        - KDC will generate a TICKET GRANTING TICKET using a KEY WHICH ONLY KDC is aware of
        - KDC will send the TGT to Client (TGT is valid for 8hrs in general)

    3. Client stores the TGT in MAIN MEMORY
        - So in case of Crash the TGT will go away
        - Next time client wants to talk to KDC it will directly use the TGT
        - This will help KDC in not doing a lookup of the client user name.
        - KDC can directly use its SPECIAL key to authenticate it.

    4. Now for Client to Communicate with the Server
        - Client will send TGT to KDC. 
        - Client will ask for a Ticket in order to TALK to Client

    5. KDC will know the PAssword of the File Server as even that is a member of the DC
        - DC will have the logon info the Server
        - KDC will use the SERVER's KEY and generate a TICKET
        - This ticket will be sent to the Client
        - Client can't use the Ticket as it doesn't know the Server's key

    6. Client will just send the TICKET got from KDC to the Server
        - Server will use its own KEY to see if the client is legitimate.
        - Server can prove that the client is legitimate as only KDC know the server's
          pasword.
        - Client will send the SERVER TICKET it got from KDC for every REQUEST that it
          sends to the SERVER
        - This way SERVER doesn't have to remember the TICKETS of the all the clients it is
          currently talking to.

https://technet.microsoft.com/en-us/library/cc780469(v=ws.10).aspx
    Possible Kerberos keys include:
    Long-term key.
    A key — known only to the target server and the KDC — with which the client’s ticket is encrypted.

    Client/server session key.
    A short-term, single-session key that is created by the KDC and used to encrypt the client-to-server and server-to-client messages after identity and authorization have been confirmed.

    KDC/user session key.
    The KDC and the user share a secret encryption key as well, which is used, for example, to encrypt the message to the client containing a session key.


4. NTLM vs Kerberos
http://sharepoint.stackexchange.com/questions/13400/ntlm-vs-kerberos
    NTLM is a properitary AuthN protocol invented by Microsoft whereas
    Kerberos is a standard protocol.

    The big difference is how the two protocols handle the authentication:
    NTLM uses a three-way handshake between the client and server and
    Kerberos uses a two-way handshake using a ticket granting service (key distribution center).
    In Kerberos the client must have access to a domain controller (which issues the tickets) whereas in
    NTLM the client contacts the server which contacts the domain controller.
    NTLM: Slower authentication because of pass-through authentication 
    Kerberos: Faster authentication because of unique ticketing system

5. Authentication vs Authorization
    - Authentication
        - Who you say you are
    - Authorization
        - What access you have

5. SMB Encryption
    1. Client sends encryption Capabilities in the Negotiate Request
    2. Server sends its Capabilities

    3. In the Session Setup, Server will decide to do encryption and send it in
       the response.

    4. If Server Level Encryption is enabled Everything after Session Setup gets encrypted
    5. If Share Level Encryption is enabled Everything after Tree connection gets encrypted

    This is the flag that the client will set to say that it is capable of encryption.
        SMB2_GLOBAL_CAP_ENCRYPTION 0x00000040                 When set, indicates that the client supports encryption

    In the Tree Connect response, following bit will be set if share level encryption is happening.
        SMB2_SHAREFLAG_ENCRYPT_DATA       0x00008000 (1000000000000000)               The server requires encryption of remote file access messages on this share

    In the Session Setup response, following bit will be set if Vserver level encryption is happening.
        SMB2_SESSION_FLAG_ENCRYPT_DATA                0x0004 (100)                       If set, the server requires encryption of messages on this session

https://blogs.msdn.microsoft.com/openspecification/2012/10/05/encryption-in-smb-3-0-a-protocol-perspective/
    Clause "Session.EncryptData is TRUE": SMB 3 session setup encryption goes as follows:
        - Initial session setup messages are un-encrypted as there is no session object (key etc).
        - Session binding requests must be signed, but not encrypted. Note:  Windows-based server does not encrypt session setup responses for session binding, regardless whether the client encrypts the session binding request. On the other side, Windows client does not encrypt session binding requests when Session.EncryptData is TRUE.
        - Spontaneous re-authentication of a valid session must be encrypted, otherwise the server returns STATUS_ACCESS_DENIED.
        - Re-authentication of an expired session is encrypted as well.
        - For re-authentication at reconnection after a broken connection, if the client lost all of its connections to the server, then the client would reconnect and create a new session (initial session setup). If the client lost some of its connections but not all, then the client would reconnect and bind to the existing session (session setup binding).

    Clause "Session.EncryptData is FALSE  and <TreeConnect|Share>.EncryptData is TRUE":
        - If the client performs TREE_DISCONNECT before a LOGOFF, the logoff will not be encrypted. 

    1. How did you do Unit Testing
        - Sample Texts and Verified the Output
        - Verify the 32byte output that gets generated

    2. Use Message Analyzer to Capture the Encrypted Traffic
       It is pretty simple.
       In Message Analyzer there are various scenarios to capture a traffic.
       One such scenario is “SMB Client Payload”.
       By using the SMB payload trace scenario, anybody with admin privileges would be able to see the data unencrypted.

        Steps:
        1.	File -> New Session -> Live Trace
        2.	Select “SMB2 Client Full Payloads” Trace Scenario and start the tracing. 
        This link explains various Trace Scenarios.

    3. Challenges During Development
        Size of Transform header is 52 bytes

        Understanding SMB Transform Header
        ProtocolId (4 bytes):  0xFD, ‘S’, ‘M’, and ‘B’ (in network order).
        Signature (16 bytes):  Signature of the encrypted message.
        Nonce (16 bytes):  An implementation-specific value that is unique for every encrypted message within a session.
        OriginalMessageSize (4 bytes):  The size in bytes of the SMB2 message.
        Reserved (2 bytes):  Set to zeros and ignored.
        EncryptionAlgorithm (2 bytes):  the value 0x0001 is for SMB2_ENCRYPTION_AES128_CCM.
        SessionId (8 bytes):  Uniquely identifies the established session for the command.   
        - Copying Large Data was failing but was working for Small data
        - We were wrongly calculating the Message Size by not taking into account the
          Start of the Request Offset.

6. How the Witness protocol works
    Data ONTAP implements the Witness protocol by using a node's SFO partner as the witness.
    In the event of a failure, the partner quickly detects the failure and notifies the SMB client.

    The Witness protocol provides enhanced failover using the following process:
        When the Hyper-V server establishes a continuously available SMB connection to Node1, the CIFS server informs the Hyper-V server that Witness is available.
        The Hyper-V server requests the IP addresses of the Witness server from Node1 and receives a list of Node2 (the SFO partner) data LIF IP addresses assigned to the Vserver.
        The Hyper-V server chooses one of the IP addresses, creates a Witness connection to Node2, and registers to be notified if the continuously available connection on Node1 must move.
        If a failover event occurs on Node1, Witness facilitates failover events, but is not involved with giveback.
        Witness detects the failover event and notifies the Hyper-V server through the Witness connection that the SMB connection must move to Node2.
        The Hyper-V server moves the SMB session to Node2 and recovers the connection without interruption to client access.

7. Multichannel
    - Nblade uses connection as Unit of Parallelism
    - Single Thread of Execution for Requests got over a connection

8. What is qtree?? And how is it different from a directory??
    A qtree is a special subdirectory under the root volume directory.

    For example if /vol/vol04nas1 is the ROOT volume directory, and a qtree training is created in it, we can refer to the qtree by traversing the following path.
        /vol/vol04nas1/training

    A qtree is different from the traditional directory on a Unix system in many ways including

    1. A qtree can be assigned a security style. We can create a qtree with Unix, NT or mixed security style.

    2. CIFS oplocks can be enabled on the qtree.
       CIFS oplocks help the client to buffer data locally, performing read ahead from an open file.
       The nature of buffering depends on the nature of oplocks granted.

    3. We can set disk space & file limits at qtree level, allowing control over resource allocation to multiple projects.

    Say we have 3 departments, finance, HR, sales and each function has separate qtree's.
    We can then assign 20 GB to sales, 100 GB to HR, since it contains training videos e.t.c. and 75 GB to finance.

    They exist inside volumes and they “plug in” to the volume at the root of that volume.
    The basic directory structure within Data ONTAP is “/vol/<vol_name>/<qtree_name>.
    Every volume plugs into the root “/vol” and every qtree plugs into the root of the volume.
    Nesting a qtree inside a qtree or under a directory is not supported.
